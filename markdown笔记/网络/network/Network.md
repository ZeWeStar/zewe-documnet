# Network

## 浏览器

### 输入网址-解析URL

![1630807942905](Network.assets/1630807942905.png)

协议: 告诉浏览器通信操作规则

+ http/https:
+ ftp:
+ file:

URI 与 URL

+ uri: 统一资源标识符（标识一个唯一资源）
+ url: 统一资源定位符（通过地址标识唯一资源，属于URI的子集）



浏览器生成**http请求头**消息，浏览器不具备发送消息的能力，委托给操作系统



### DNS域名转换IP

操作系统发送http消息是查询网址中服务器域名对应的IP地址。在委托操作系统发送消息时，必须要提供的不是通信对象的域名，而是它的IP地址。因此，在生成HTTP消息之后，下一个步骤就是根据域名查询IP地址。

#### IP的掩码表示法

IP地址是一串32比特的数字，按照8比特（1字节）为一组分成4组，分别用十进制表示然后再用圆点隔开。

其中由网络号与主机号组成

![1630825454990](Network.assets/1630825454990.png)

+ 主机号部分全部为0代表整个子网而不是子网中的某台设备
+ 主机号部分全部为1代表向子网上所有设备发送包，即广播

#### 什么是DNS

使用的方案是让人来使用名称，让路由器来使用IP地址。为了填补两者之间的障碍，需要有一个机制能够通过名称来查询IP地址，或者通过IP地址来查询名称，这样就能够在人和机器双方都不做出牺牲的前提下完美地解决问题。这个机制就是DNS。

如果我们不用IP地址而是改用名称会怎么样呢？

IP地址的长度为32比特，也就是4字节，相对地，域名最短也要几十个字节，最长甚至可以达到255字节。换句话说，使用IP地址只需要处理4字节的数字，而域名则需要处理几十个到255个字节的字符，这增加了路由器的负担，传送数据也会花费更长的时间

#### Socket库提供查询DNS入口

查询ip 需要向最近的DNS服务器查询、我们的计算机上一定有相应的DNS客户端，而相当于DNS客户端的部分称为DNS解析器，或者简称解析器。通过DNS查询IP地址的操作称为域名解析。

解析器实际上是一段程序，它包含在操作系统的Socket库中，

Socket库也是一种库，其中包含的程序组件可以让其他的应用程序调用操作系统的网络功能，Linux Socket 函数库是从Berkeley大学开发的BSD Linux系统中移植过来的。BSD Socket 接口在众多Unix系统中被广泛支持TCP/IP通信接口。而解析器就是这个库中的其中一种程序组件。

**注意：向发送DNS发送消息是委托给操作系统的`协议栈`来发送的。**服务器中的DNS地址是预先设置好的。



### DNS服务大接力

#### DNS服务器返回查询结果

![1630827325314](Network.assets/1630827325314.png)



+ 域名：服务器、邮件服务器（邮件地址中@后面的部分）的名称

+ Class

  在最早设计DNS方案时，DNS在互联网以外的其他网络中的应用也被考虑到了，而Class就是用来识别网络的信息。不过，如今除了互联网并没有其他的网络了，因此Class的值永远是代表互联网的IN

+ 记录类型

  当类型为A时，表示域名对应的是IP地址；当类型为MX时，表示域名对应的是邮件服务器。对于不同的记录类型，服务器向客户端返回的信息也会不同



#### 域名层次结构分层DNS服务器

![1630827530499](Network.assets/1630827530499.png)



#### 查找接力

![1630827580554](Network.assets/1630827580554.png)

注：DNS服务器有一个缓存[插图]功能，可以记住之前查询过的域名。如果要查询的域名和相关信息已经在缓存中，那么就可以直接返回响应。



### 委托协议栈发送消息

知道了IP地址之后，就可以委托操作系统内部的协议栈向这个目标IP地址，也就是我们要访问的Web服务器发送消息了。要发送给Web服务器的HTTP消息是一种数字信息（digital data）。

向操作系统内部的协议栈发出委托时，需要按照指定的顺序来调用Socket库中的程序组件。简单来说，收发数据的两台计算机之间连接了一条数据通道，数据沿着这条通道流动，最终到达目的地。两套接字之间的管道。

![1630832913024](Network.assets/1630832913024.png)

#### 管道

运营管道需要经历四个阶段：（1）创建套接字（创建套接字阶段）、（2）将管道连接到服务器端的套接字上（连接阶段）、（3）收发数据（通信阶段）、（4）断开管道并删除套接字（断开阶段）。

![1630833187940](Network.assets/1630833187940.png)

##### 创建套接字（创建套接字阶段）

客户端创建套接字的操作非常简单，只要调用Socket库中的socket程序组件[插图]就可以了。套接字创建完成后，协议栈会返回一个描述符，应用程序会将收到的描述符存放在内存中。描述符是用来识别不同的套接字的。



##### 将管道连接到服务器端的套接字上（连接阶段）

需要委托协议栈将客户端创建的套接字与服务器那边的套接字连接起来。应用程序通过调用Socket库中的名为connect的程序组件来完成这一操作。这里的要点是当调用connect时，需要指定描述符、服务器IP地址和端口号这3个参数。

+ 描述符：connect会将应用程序指定的描述符告知协议栈，然后协议栈根据这个描述符来判断到底使用哪一个套接字去和服务器端的套接字进行连接
+ ip: 通过DNS服务器查询得到的我们要访问的服务器的IP地址
+ port：知道了IP地址，我们就可以识别出网络上的某台计算机。但是，连接操作的对象是某个具体的套接字，因此必须要识别到具体的套接字才行。同时指定IP地址和端口号时，就可以明确识别出某台具体的计算机上的某个具体的套接字。



##### 收发数据（通信阶段）

只要将数据送入套接字，数据就会被发送到对方的套接字中。当然，应用程序无法直接控制套接字，因此还是要通过Socket库委托协议栈来完成这个操作。这个操作需要使用write这个程序组件。应用程序需要在内存中准备好要发送的数据、由于套接字中已经保存了已连接的通信对象的相关信息，所以只要通过描述符指定套接字，就可以识别出通信对象，并向其发送数据。接着，发送数据会通过网络到达我们要访问的服务器。

接收消息的操作是通过Socket库中的read程序组件委托协议栈来完成的。调用read时需要指定用于存放接收到的响应消息的内存地址，这一内存地址称为接收缓冲区。于是，当服务器返回响应消息时，read就会负责将接收到的响应消息存放到接收缓冲区中。由于**接收缓冲区是一块位于应用程序内部的内存空间，因此当消息被存放到接收缓冲区中时，就相当于已经转交给了应用程序。**



##### 断开管道并删除套接字（断开阶段）

调用Socket库的close程序组件进入断开阶段。最终，连接在套接字之间的管道会被断开，套接字本身也会被删除。







